% !TEX root = ../main.tex
% !TEX spellcheck = en_GB

\chapter{Implementation}
\section{Clock}
The \SAMD is able to run with a clock frequency of \SI{48}{\mega\hertz}, but will during start up, this is not active. It is therefore necessary to activate not just the clock called \textit{DFLL48M} but also set up the reference clock, the generic clocks and the required multiplexers.

During operation \SAMD is able to maintain a given frequency through a DFLL(Digital Frequency Lock Loop).
This system relies on a secondary clock as a reference source for the main clock.
In the following list it is shown in what order the clocks and registers should be activated in order to get a stable system.

\begin{enumerate}
	\item Enable XOSC32K clock (External on-board 32.768Hz oscillator). Used as reference for \SI{48}{\mega\hertz} clock.
	\item Set Generic Clock Generator (1) source to XOSC32K.
	\item Active and set reference for Generic Clock Multiplexer.
	\item Enable DFLL48M.
	\item Set DFLL48M as source for Generic Clock Generator 0.
	\item Edit Pre scaler for OSCM clock to obtain \SI{8}{\mega\hertz}.
	\item Set OSC8M as source for Generic Clock Generator 3.
\end{enumerate} 

Going through the data sheet of \SAMD the group was not able to configure the clock to run correctly. It was therefore assessed, that using a free open source implementation from example code, would speed up progress and result in a working prototype.

\section{UART: Configuration}
This section will describe the processor specific register configuration needed to get the UART running on \SAMD. Mainly there are two control register A and B, but also a register for interrupt enabling and one for baud rate.

\fxnote{Tables ?}X contains values for data, if a bit or variable is not mentioned in the table, assume it to be 0.

\begin{table}[H]
	\begin{tabular}{lr}
		\toprule
		Name & Value (Sercom2 || Sercom5) \\
		\midrule
		Data Order & 0 \\ 
		Communication Mode & 0 \\ 
		Frame Format & 0 \\ 
		Receive Data Pinout & 1 || 3 \\ 
		Transmit Data Pinout & 0 || 1 \\ 
		Sample Rate & 1 \\ 
		Operating Mode & 1 \\ 
		\bottomrule
	\end{tabular} 
	\centering
	\caption{Control A register values.}
	\label{tab:UARTControlA}
\end{table}

\begin{table}[H]
	\begin{tabular}{lr}
		\toprule
		Name & Value \\
		\midrule
		Receiver Enable & 1 \\ 
		Transmitter Enable & 1 \\ 
		Parity Mode & 0 \\ 
		Stop Bit Mode & 0 \\ 
		Character Size & 0 \\ 
		\bottomrule
	\end{tabular} 
	\centering
	\caption{Control b register values.}
	\label{tab:UARTControlB}
\end{table}

\begin{table}[H]
	\begin{tabular}{lr}
		\toprule
		Name & Value \\
		\midrule
		Receive Complete Interrupt Enable & 1 \\ 
		Transmit Complete Interrupt Enable & 1 \\ 
		\bottomrule
	\end{tabular} 
	\centering
	\caption{Interrupt Enable register values.}
	\label{tab:UARTINTENSET}
\end{table}

\subsection{Baud Rate}
To implement baud rate calculation, the data sheet for \SAMD was consulted. The group expected to use asynchronous arithmetic baud, and started to set up the implementation of this. After having a functional UART set up, it was noticed that the baud rate was very unstable, having a range from 9300 -> 9800 bits/s. This meant that the \GPS and \SARA module communications was scrambled at times. 
Trying to understand the UART set up better, an example from Arduino sketches was reviewed. In the example asynchronous fractional baud calculation was used, and the group decided to test out this approach. Although nothing was noticeably change in the control registers, from the previous tests, the UART was now stable.
Following will be a example of fractional baud value calculation.

\[BAUD = \frac{f_{ref}}{S*f_{BAUD}} - \frac{FP}{8}\]
\begin{verbatim}	
uint32_t baudTimes8 = (SystemCoreClock * 8) / (16 * uartSetup.baudRate); uint16_t baudReg = ((baudTimes8 \% 8)<<13) | (baudTimes8 >> 3);	
\end{verbatim}
\fxnote{Code Sample: }

\fxnote{GPS: e.g. Power saving settings}
\fxnote{GSM: Context setup and so forth}
